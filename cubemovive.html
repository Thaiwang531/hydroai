<!DOCTYPE html>  
<html lang="zh-CN">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <title>ç«‹æ–¹ä½“åŠ¨ç”»æ¼”ç¤º - è‡ªåŠ¨æ’­æ”¾ç‰ˆ</title>  
    <style>  
        body { margin: 0; overflow: hidden; font-family: 'Microsoft YaHei', sans-serif; background-color: #E0F7FA; }  
          
        /* å­—å¹•åŒºåŸŸ */  
        #caption-container {  
            position: absolute;  
            bottom: 10%;  
            left: 50%;  
            transform: translateX(-50%);  
            width: 80%;  
            max-width: 800px;  
            background: rgba(255, 255, 255, 0.9);  
            padding: 20px;  
            border-radius: 20px;  
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);  
            text-align: center;  
            border: 3px solid #00BCD4;  
            transition: all 0.5s;  
        }  
  
        #main-text {  
            font-size: 28px;  
            font-weight: bold;  
            color: #333;  
            margin-bottom: 10px;  
        }  
  
        #sub-text {  
            font-size: 18px;  
            color: #0097A7;  
            font-weight: bold;  
        }  
  
        /* è¿›åº¦æ¡ */  
        #progress-bar {  
            position: absolute;  
            bottom: 0;  
            left: 0;  
            height: 5px;  
            background: #FF9800;  
            width: 0%;  
            transition: width 0.1s linear;  
        }  
  
        /* è§’æ ‡ */  
        #badge {  
            position: absolute;  
            top: 20px;  
            left: 20px;  
            background: #FF6B6B;  
            color: white;  
            padding: 10px 20px;  
            border-radius: 30px;  
            font-weight: bold;  
            box-shadow: 0 4px 10px rgba(255, 107, 107, 0.4);  
        }  
    </style>  
    <script type="importmap">  
        {  
            "imports": {  
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",  
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"  
            }  
        }  
    </script>  
</head>  
<body>  
  
    <div id="badge">ğŸ¬ è‡ªåŠ¨æ¼”ç¤ºæ¨¡å¼</div>  
  
    <div id="caption-container">  
        <div id="main-text">å‡†å¤‡å¼€å§‹...</div>  
        <div id="sub-text">è¯·ä»”ç»†è§‚å¯Ÿå±å¹•</div>  
        <div id="progress-bar"></div>  
    </div>  
  
    <script type="module">  
        import * as THREE from 'three';  
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';  
  
        // --- åœºæ™¯è®¾ç½® ---  
        const scene = new THREE.Scene();  
        scene.background = new THREE.Color(0xE0F7FA);  
  
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);  
        camera.position.set(10, 10, 14);  
  
        const renderer = new THREE.WebGLRenderer({ antialias: true });  
        renderer.setSize(window.innerWidth, window.innerHeight);  
        renderer.shadowMap.enabled = true;  
        document.body.appendChild(renderer.domElement);  
  
        // ç¯å…‰  
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);  
        scene.add(ambientLight);  
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);  
        dirLight.position.set(5, 10, 7);  
        dirLight.castShadow = true;  
        scene.add(dirLight);  
  
        // æ§åˆ¶å™¨ (ä¿ç•™è‡ªåŠ¨æ—‹è½¬ï¼Œä½†ä¹Ÿå…è®¸æ‰‹åŠ¨æ‹–æ‹½)  
        const controls = new OrbitControls(camera, renderer.domElement);  
        controls.enableDamping = true;  
        controls.autoRotate = true; // å¼€å¯è‡ªåŠ¨æ—‹è½¬é•œå¤´  
        controls.autoRotateSpeed = 1.0;   
  
        // åœ°é¢  
        const gridHelper = new THREE.GridHelper(30, 30, 0x888888, 0xbbbbbb);  
        scene.add(gridHelper);  
  
        // --- å¯¹è±¡ç»„ ---  
        const groupVolume = new THREE.Group();  
        const groupNet = new THREE.Group();  
        scene.add(groupVolume);  
        scene.add(groupNet);  
  
        // --- 1. ç§¯æœ¨ç”Ÿæˆé€»è¾‘ ---  
        let lastDim = { l:0, w:0, h:0 };  
  
        function createBlocks(L, W, H) {  
            // åªæœ‰å½“å°ºå¯¸å˜åŒ–æ—¶æ‰é‡æ–°ç”Ÿæˆï¼ŒèŠ‚çœæ€§èƒ½  
            if (L === lastDim.l && W === lastDim.w && H === lastDim.h) return;  
            lastDim = { l:L, w:W, h:H };  
  
            // æ¸…ç©º  
            while(groupVolume.children.length > 0) groupVolume.remove(groupVolume.children[0]);  
  
            const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);  
            const material = new THREE.MeshStandardMaterial({ color: 0xFFEB3B });  
            const edgesGeo = new THREE.EdgesGeometry(geometry);  
            const edgesMat = new THREE.LineBasicMaterial({ color: 0xD3A600 });  
  
            const offsetX = (L - 1) / 2;  
            const offsetZ = (W - 1) / 2;  
  
            for (let x = 0; x < L; x++) {  
                for (let y = 0; y < H; y++) {  
                    for (let z = 0; z < W; z++) {  
                        const cube = new THREE.Mesh(geometry, material);  
                        cube.position.set(x - offsetX, y + 0.5, z - offsetZ);  
                          
                        // ç®€å•çš„å…¥åœºåŠ¨ç”»æ•ˆæœ  
                        cube.scale.set(0,0,0);  
                          
                        // è¾¹æ¡†  
                        const line = new THREE.LineSegments(edgesGeo, edgesMat);  
                        cube.add(line);  
                          
                        groupVolume.add(cube);  
                    }  
                }  
            }  
        }  
  
        // ç®€å•çš„ç¼©æ”¾åŠ¨ç”»æ›´æ–°  
        function updateBlockAnimation() {  
            groupVolume.children.forEach(cube => {  
                if (cube.scale.x < 1) {  
                    cube.scale.addScalar(0.1);  
                }  
            });  
        }  
  
        // --- 2. å±•å¼€å›¾ç”Ÿæˆé€»è¾‘ (æ ‡å‡†åå­—) ---  
        let netGroups = [];  
          
        function createNet() {  
            if (groupNet.children.length > 0) return; // å·²ç»åˆ›å»ºè¿‡  
  
            // è¾…åŠ©ï¼šåˆ›å»ºå¸¦æ•°å­—çš„é¢  
            function createFaceMesh(num) {  
                const canvas = document.createElement('canvas');  
                canvas.width = 128; canvas.height = 128;  
                const ctx = canvas.getContext('2d');  
                ctx.fillStyle = '#FFCC80'; ctx.fillRect(0,0,128,128);  
                ctx.strokeStyle = '#EF6C00'; ctx.lineWidth = 8; ctx.strokeRect(0,0,128,128);  
                ctx.fillStyle = '#E65100'; ctx.font = 'bold 60px Arial';  
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(num, 64, 64);  
                const mesh = new THREE.Mesh(  
                    new THREE.PlaneGeometry(1.5, 1.5), // ç¨å¾®å¤§ä¸€ç‚¹  
                    new THREE.MeshStandardMaterial({ map: new THREE.CanvasTexture(canvas), side: THREE.DoubleSide })  
                );  
                return mesh;  
            }  
  
            // é€’å½’æ„å»ºç®€å•çš„åå­—å±•å¼€å›¾  
            // ç»“æ„: Root(1) -> U(2), D(4), L(5), R(3)->R(6)  
              
            const root = new THREE.Group();  
            root.position.y = 0.05; // ç¦»åœ°  
            const m1 = createFaceMesh(1); m1.rotation.x = -Math.PI/2; root.add(m1);  
              
            function addLimb(parent, dir, num) {  
                const g = new THREE.Group();  
                const m = createFaceMesh(num);  
                // å…³èŠ‚ä½ç½® (åŸºäº1.5çš„å¤§å°)  
                const size = 1.5;  
                const half = size/2;  
  
                if(dir==='u') { g.position.set(0, 0, -half); m.position.set(0, -half, 0); } // æ³¨æ„3Dç©ºé—´æ–¹å‘  
                // ä¿®æ­£é€»è¾‘ï¼šå¹³é¢å¹³é“ºåœ¨XZå¹³é¢ã€‚  
                // Rootåœ¨ 0,0. Uåœ¨ 0, -size(Z).   
                // æ—‹è½¬è½´ï¼šè¿æ¥å¤„ã€‚  
                  
                // é‡æ–°ç®€åŒ–é€»è¾‘ï¼š  
                // å…³èŠ‚ Group åœ¨è¿æ¥çº¿ã€‚ Mesh ç›¸å¯¹äºå…³èŠ‚åç§»ã€‚  
                  
                // U (ä¸Š) -> Zè´Ÿæ–¹å‘  
                if(dir==='u') { g.position.z = -half; m.position.z = -half; }   
                // D (ä¸‹) -> Zæ­£æ–¹å‘  
                if(dir==='d') { g.position.z = half; m.position.z = half; }  
                // L (å·¦) -> Xè´Ÿæ–¹å‘  
                if(dir==='l') { g.position.x = -half; m.position.x = -half; }  
                // R (å³) -> Xæ­£æ–¹å‘  
                if(dir==='r') { g.position.x = half; m.position.x = half; }  
  
                m.rotation.x = -Math.PI/2; // èººå¹³  
                  
                g.userData = { dir: dir };  
                g.add(m);  
                parent.add(g);  
                netGroups.push(g);  
                return m; // è¿”å›meshä½œä¸ºå¯èƒ½çš„çˆ¶çº§ï¼ˆè™½ç„¶è¿™é‡Œåªç”¨groupåšçˆ¶çº§ï¼‰  
            }  
  
            // æ„å»ºæ ‘  
            const size = 1.5;  
            const half = size/2;  
              
            // 1. æ ¹èŠ‚ç‚¹ Mesh  
            // 2. å­èŠ‚ç‚¹ (Group)  
              
            // Up (2)  
            const g2 = new THREE.Group(); g2.position.z = -half;   
            const m2 = createFaceMesh(2); m2.position.z = -half; m2.rotation.x = -Math.PI/2;  
            g2.add(m2); g2.userData = {dir:'u'}; root.add(g2); netGroups.push(g2);  
  
            // Down (4)  
            const g4 = new THREE.Group(); g4.position.z = half;  
            const m4 = createFaceMesh(4); m4.position.z = half; m4.rotation.x = -Math.PI/2;  
            g4.add(m4); g4.userData = {dir:'d'}; root.add(g4); netGroups.push(g4);  
  
            // Left (5)  
            const g5 = new THREE.Group(); g5.position.x = -half;  
            const m5 = createFaceMesh(5); m5.position.x = -half; m5.rotation.x = -Math.PI/2;  
            g5.add(m5); g5.userData = {dir:'l'}; root.add(g5); netGroups.push(g5);  
  
            // Right (3)  
            const g3 = new THREE.Group(); g3.position.x = half;  
            const m3 = createFaceMesh(3); m3.position.x = half; m3.rotation.x = -Math.PI/2;  
            g3.add(m3); g3.userData = {dir:'r'}; root.add(g3); netGroups.push(g3);  
  
            // Right -> Right (6) (æŒ‚åœ¨ m3 ä¸Š? ä¸ï¼ŒæŒ‚åœ¨ g3 é‡Œçš„ m3 ä½ç½®?   
            // æŒ‚åœ¨ g3 ä¸Šï¼Œä½ç½®è¦åç§»)  
            // ç®€å•ç‚¹ï¼ŒæŒ‚åœ¨ g3 å†…éƒ¨ï¼Œä½ç½®ç›¸å¯¹äº g3 åŸç‚¹æ˜¯ x=size  
            const g6 = new THREE.Group(); g6.position.x = size; // è¿™é‡Œçš„xæ˜¯ç›¸å¯¹äºg3çš„  
            const m6 = createFaceMesh(6); m6.position.x = half; m6.rotation.x = -Math.PI/2;  
            g6.add(m6); g6.userData = {dir:'r'}; g3.add(g6); netGroups.push(g6); // æ³¨æ„è¿™é‡ŒåŠ åˆ°äº† g3  
  
            groupNet.add(root);  
        }  
  
        function updateNetFold(percent) {  
            const angle = (percent / 100) * (Math.PI / 2);  
            netGroups.forEach(g => {  
                const d = g.userData.dir;  
                // å‘ä¸ŠæŠ˜èµ· (Box closing)  
                if(d==='u') g.rotation.x = angle;  // Zè´Ÿï¼Œç»•Xè½¬  
                if(d==='d') g.rotation.x = -angle; // Zæ­£ï¼Œç»•Xåè½¬  
                if(d==='l') g.rotation.z = -angle; // Xè´Ÿï¼Œç»•Zè½¬ (æ³¨æ„åæ ‡è½´)  
                if(d==='r') g.rotation.z = angle;  // Xæ­£  
            });  
        }  
  
        // --- 3. å¯¼æ¼”ç³»ç»Ÿ (Animation Loop) ---  
          
        const captionMain = document.getElementById('main-text');  
        const captionSub = document.getElementById('sub-text');  
        const progressBar = document.getElementById('progress-bar');  
  
        const LOOP_DURATION = 30; // æ€»æ—¶é•¿30ç§’  
  
        function updateTimeline() {  
            const time = (Date.now() % (LOOP_DURATION * 1000)) / 1000;  
            const progress = (time / LOOP_DURATION) * 100;  
            progressBar.style.width = `${progress}%`;  
  
            // å‰§æœ¬é˜¶æ®µ  
            if (time < 4) {  
                // Phase 0: Intro  
                captionMain.innerText = "ğŸ§Š è®¤è¯†ä½“ç§¯";  
                captionSub.innerText = "è¿™æ˜¯ 1 ä¸ªå•ä½çš„å°æ­£æ–¹ä½“";  
                groupVolume.visible = true; groupNet.visible = false;  
                createBlocks(1, 1, 1);  
            }   
            else if (time < 9) {  
                // Phase 1: å˜é•¿  
                captionMain.innerText = "ğŸ“ ç¬¬ä¸€æ­¥ï¼šå˜é•¿";  
                captionSub.innerText = "é•¿ = 4ï¼Œç°åœ¨æœ‰ 4 ä¸ªæ–¹å—";  
                createBlocks(4, 1, 1);  
            }  
            else if (time < 14) {  
                // Phase 2: å˜å®½  
                captionMain.innerText = "ğŸ“ ç¬¬äºŒæ­¥ï¼šå˜å®½";  
                captionSub.innerText = "å®½ = 3ï¼Œé“ºæ»¡ä¸€å±‚ (4 Ã— 3 = 12ä¸ª)";  
                createBlocks(4, 3, 1);  
            }  
            else if (time < 20) {  
                // Phase 3: å˜é«˜  
                captionMain.innerText = "ğŸ“¦ ç¬¬ä¸‰æ­¥ï¼šå˜é«˜ (ä½“ç§¯)";  
                captionSub.innerText = "é«˜ = 3ï¼Œä¸€å…±ä¸‰å±‚ (12 Ã— 3 = 36ä¸ª)";  
                createBlocks(4, 3, 3);  
            }  
            else if (time < 22) {  
                // Transition  
                captionMain.innerText = "âœ¨ æ¥ä¸‹æ¥...";  
                captionSub.innerText = "æˆ‘ä»¬è¦æŠŠå®ƒæ‹†å¼€çœ‹çœ‹ï¼";  
                // groupVolume.visible = false; // é—ªçƒä¸€ä¸‹ï¼Ÿ  
            }  
            else {  
                // Phase 4: å±•å¼€å›¾  
                groupVolume.visible = false;  
                groupNet.visible = true;  
                createNet();  
  
                // è®¡ç®—æŠ˜å åŠ¨ç”»   
                // 22s -> 24s (Unfold: 100% -> 0%)  
                // 24s -> 26s (Wait)  
                // 26s -> 29s (Fold: 0% -> 100%)  
                  
                let foldPercent = 0;  
                if (time < 24) {  
                    // åˆšå¼€å§‹æ˜¯ç«‹æ–¹ä½“ï¼Œæ…¢æ…¢å±•å¼€  
                    captionMain.innerText = "ğŸ“„ å±•å¼€";  
                    captionSub.innerText = "æ²¿ç€æ£±å‰ªå¼€ï¼Œå˜æˆå¹³é¢å›¾";  
                    // map time 22->24 to 100->0  
                    const p = (time - 22) / 2;   
                    foldPercent = 100 * (1 - p);  
                } else if (time < 26) {  
                    // å±•å¼€çŠ¶æ€å±•ç¤º  
                    captionMain.innerText = "ğŸ‘€ è§‚å¯Ÿ";  
                    captionSub.innerText = "è¿™å«â€œç«‹æ–¹ä½“å±•å¼€å›¾â€";  
                    foldPercent = 0;  
                } else {  
                    // æŠ˜å å›å»  
                    captionMain.innerText = "ğŸ“¦ æŠ˜å ";  
                    captionSub.innerText = "å›´èµ·æ¥ï¼Œå˜å›æ­£æ–¹ä½“ï¼";  
                    // map time 26->29 to 0->100  
                    const p = (time - 26) / 3;  
                    foldPercent = Math.min(100, p * 100);  
                }  
                  
                updateNetFold(foldPercent);  
            }  
        }  
  
  
        // --- æ¸²æŸ“å¾ªç¯ ---  
        function animate() {  
            requestAnimationFrame(animate);  
              
            controls.update(); // å¤„ç†è‡ªåŠ¨æ—‹è½¬  
            updateTimeline();  
            updateBlockAnimation();  
  
            renderer.render(scene, camera);  
        }  
  
        // çª—å£è‡ªé€‚åº”  
        window.addEventListener('resize', () => {  
            camera.aspect = window.innerWidth / window.innerHeight;  
            camera.updateProjectionMatrix();  
            renderer.setSize(window.innerWidth, window.innerHeight);  
        });  
  
        animate();  
  
    </script>  
</body>  
</html>  

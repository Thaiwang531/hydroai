<!DOCTYPE html>  
<html lang="zh-CN">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <title>3Dåæ ‡å¤§å†’é™© - å°å­¦ç”Ÿç‰ˆ</title>  
    <style>  
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #87CEEB; }  
          
        /* æ§åˆ¶é¢æ¿æ ·å¼ */  
        #ui-container {  
            position: absolute;  
            top: 20px;  
            left: 20px;  
            background: rgba(255, 255, 255, 0.95);  
            padding: 20px;  
            border-radius: 15px;  
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);  
            width: 320px;  
            z-index: 10;  
            border: 3px solid #FFD700;  
        }  
  
        h1 { margin: 0 0 15px 0; font-size: 22px; color: #333; text-align: center; }  
          
        .input-group { margin-bottom: 15px; display: flex; align-items: center; justify-content: space-between; }  
        .input-group label { font-weight: bold; font-size: 18px; }  
          
        /* å½©è‰²æ ‡ç­¾ */  
        .label-x { color: #ff3333; }  
        .label-y { color: #3366ff; }  
  
        input[type="number"] {  
            width: 80px;  
            padding: 8px;  
            font-size: 18px;  
            border: 2px solid #ddd;  
            border-radius: 8px;  
            text-align: center;  
        }  
  
        button {  
            width: 100%;  
            padding: 12px;  
            background-color: #4CAF50;  
            color: white;  
            border: none;  
            border-radius: 10px;  
            font-size: 18px;  
            cursor: pointer;  
            transition: transform 0.1s, background-color 0.2s;  
            font-weight: bold;  
            box-shadow: 0 4px 0 #2E7D32;  
        }  
  
        button:active {  
            transform: translateY(4px);  
            box-shadow: 0 0 0 #2E7D32;  
        }  
  
        #message {  
            margin-top: 15px;  
            padding: 10px;  
            background: #e8f5e9;  
            border-radius: 8px;  
            color: #2e7d32;  
            font-size: 14px;  
            line-height: 1.4;  
        }  
  
        /* åæ ‡æŒ‡ç¤ºå™¨æ°”æ³¡ */  
        #bubble {  
            position: absolute;  
            background: white;  
            padding: 5px 10px;  
            border-radius: 20px;  
            font-weight: bold;  
            pointer-events: none;  
            display: none;  
            transform: translate(-50%, -100%);  
            border: 2px solid #333;  
            margin-top: -20px;  
        }  
  
        .legend {  
            margin-top: 10px;  
            font-size: 12px;  
            color: #666;  
        }  
        .dot { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; }  
    </style>  
    <!-- å¼•å…¥ Three.js (ä½¿ç”¨CDN) -->  
    <script type="importmap">  
        {  
            "imports": {  
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",  
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"  
            }  
        }  
    </script>  
</head>  
<body>  
  
    <!-- UI ç•Œé¢ -->  
    <div id="ui-container">  
        <h1>ğŸ—ºï¸ åæ ‡å¯»å®å›¾</h1>  
          
        <div class="input-group">  
            <label class="label-x">ğŸ”´ X (å·¦å³):</label>  
            <input type="number" id="inputX" value="3" min="-5" max="5">  
        </div>  
          
        <div class="input-group">  
            <label class="label-y">ğŸ”µ Y (å‰å):</label>  
            <input type="number" id="inputY" value="2" min="-5" max="5">  
        </div>  
  
        <button id="goBtn">ğŸš€ å‡ºå‘ï¼</button>  
  
        <div id="message">  
            ğŸ‘‹ å—¨ï¼æˆ‘æ˜¯å°æ–¹ã€‚<br>  
            è¯·å‘Šè¯‰æˆ‘ <b>(X, Y)</b> åæ ‡ï¼Œæˆ‘å°±ä¼šèµ°åˆ°é‚£é‡Œå»ï¼<br>  
            <b>(0, 0)</b> æ˜¯æˆ‘çš„å®¶å“¦ã€‚  
        </div>  
  
        <div class="legend">  
            <div><span class="dot" style="background:red;"></span>çº¢è‰²çº¿æ˜¯ Xè½´ (æ¨ªå‘)</div>  
            <div><span class="dot" style="background:blue;"></span>è“è‰²çº¿æ˜¯ Yè½´ (çºµå‘)</div>  
        </div>  
    </div>  
  
    <!-- è§’è‰²å¤´é¡¶çš„åæ ‡æ°”æ³¡ -->  
    <div id="bubble"></div>  
  
    <script type="module">  
        import * as THREE from 'three';  
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';  
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';  
  
        // --- 1. åœºæ™¯åˆå§‹åŒ– ---  
        const scene = new THREE.Scene();  
        scene.background = new THREE.Color(0x87CEEB); // å¤©ç©ºè“èƒŒæ™¯  
        scene.fog = new THREE.Fog(0x87CEEB, 10, 50);  
  
        // ç›¸æœºè®¾ç½®  
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);  
        camera.position.set(0, 12, 15); // æ”¾åœ¨é«˜å¤„ä¿¯è§†  
        camera.lookAt(0, 0, 0);  
  
        const renderer = new THREE.WebGLRenderer({ antialias: true });  
        renderer.setSize(window.innerWidth, window.innerHeight);  
        renderer.shadowMap.enabled = true;  
        document.body.appendChild(renderer.domElement);  
  
        // ç¯å…‰  
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);  
        scene.add(ambientLight);  
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);  
        dirLight.position.set(10, 20, 10);  
        dirLight.castShadow = true;  
        scene.add(dirLight);  
  
        // æ§åˆ¶å™¨ (å…è®¸é¼ æ ‡æ—‹è½¬åœºæ™¯)  
        const controls = new OrbitControls(camera, renderer.domElement);  
        controls.enableDamping = true;  
        controls.maxPolarAngle = Math.PI / 2.2; // ä¸å…è®¸é’»åˆ°åœ°åº•  
  
        // --- 2. åˆ›å»ºç½‘æ ¼ä¸–ç•Œ ---  
          
        // åœ°é¢  
        const planeGeometry = new THREE.PlaneGeometry(20, 20);  
        const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xf0f0f0 });  
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);  
        plane.rotation.x = -Math.PI / 2;  
        plane.receiveShadow = true;  
        scene.add(plane);  
  
        // ç½‘æ ¼çº¿  
        const gridSize = 10; // èŒƒå›´ -5 åˆ° 5  
        const gridDivisions = 10;  
        const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0xdddddd, 0xdddddd);  
        scene.add(gridHelper);  
  
        // --- 3. åˆ›å»ºå¯è§†åŒ–çš„ X å’Œ Y è½´ (åŠ ç²—) ---  
          
        function createAxisLine(color, start, end) {  
            const material = new THREE.MeshBasicMaterial({ color: color });  
            const geometry = new THREE.CylinderGeometry(0.05, 0.05, 10, 8);  
            const cylinder = new THREE.Mesh(geometry, material);  
              
            // è®¡ç®—ä¸­å¿ƒç‚¹å’Œæ—‹è½¬  
            const center = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);  
            cylinder.position.copy(center);  
            cylinder.position.y = 0.01; // ç¨å¾®æµ®èµ·ä¸€ç‚¹ç‚¹é¿å…é‡å   
              
            if (Math.abs(start.x - end.x) > 0.1) {  
                cylinder.rotation.z = Math.PI / 2; // æ¨ªå‘ Xè½´  
            } else {  
                cylinder.rotation.x = Math.PI / 2; // çºµå‘ Zè½´(ä¹Ÿå°±æ˜¯æˆ‘ä»¬çš„Y)  
            }  
            return cylinder;  
        }  
  
        // Xè½´ (çº¢)  
        const xAxis = createAxisLine(0xff3333, new THREE.Vector3(-5,0,0), new THREE.Vector3(5,0,0));  
        scene.add(xAxis);  
  
        // Yè½´ (è“ - åœ¨3Dä¸­å®é™…æ˜¯Zè½´æ–¹å‘ï¼Œä½†æˆ‘ä»¬æ•™åšY)  
        const yAxis = createAxisLine(0x3366ff, new THREE.Vector3(0,0,-5), new THREE.Vector3(0,0,5));  
        scene.add(yAxis);  
  
        // --- 4. è¾…åŠ©æ–‡å­—æ ‡ç­¾ (ç”Ÿæˆè´´å›¾) ---  
        // ä½¿ç”¨Canvasç”Ÿæˆæ•°å­—è´´å›¾ï¼Œé¿å…å­—ä½“æ–‡ä»¶åŠ è½½é—®é¢˜  
        function createTextSprite(text, color) {  
            const canvas = document.createElement('canvas');  
            const ctx = canvas.getContext('2d');  
            canvas.width = 64;  
            canvas.height = 64;  
            ctx.fillStyle = color;  
            ctx.font = "bold 40px Arial";  
            ctx.textAlign = "center";  
            ctx.textBaseline = "middle";  
            ctx.fillText(text, 32, 32);  
              
            const texture = new THREE.CanvasTexture(canvas);  
            const material = new THREE.SpriteMaterial({ map: texture });  
            const sprite = new THREE.Sprite(material);  
            sprite.scale.set(1, 1, 1);  
            return sprite;  
        }  
  
        // æ·»åŠ åœ°é¢æ•°å­—  
        for(let i = -5; i <= 5; i++) {  
            if(i === 0) continue; // åŸç‚¹ä¸æ ‡  
              
            // Xè½´æ•°å­—  
            const spriteX = createTextSprite(i.toString(), "#ff3333");  
            spriteX.position.set(i, 0.5, 0);  
            scene.add(spriteX);  
  
            // Yè½´æ•°å­— (å®é™…Z) - æ³¨æ„ï¼š3Dä¸­Zè½´å‘å±å¹•å¤–æ˜¯æ­£ï¼Œå‘å†…æ˜¯è´Ÿã€‚  
            // ä¸ºäº†ç¬¦åˆæ•°å­¦è¯¾æœ¬ä¹ æƒ¯ï¼ˆä¸ŠåŒ—ä¸‹å—ï¼‰ï¼Œæˆ‘ä»¬å°†å±å¹•å†…è®¾ä¸ºYçš„æ­£æ–¹å‘ï¼Ÿ  
            // è¿™é‡Œä¸ºäº†ç›´è§‚ï¼šå±å¹•å‘å³æ˜¯X+ï¼Œå±å¹•å‘å†…æ˜¯Y-(Z-)ã€‚  
            // è®©æˆ‘ä»¬ç»Ÿä¸€é€»è¾‘ï¼šä¸ºäº†åƒåœ°å›¾ï¼Œæˆ‘ä»¬å®šä¹‰ï¼š  
            // X+ = å³, X- = å·¦  
            // Z+ (å‰) = æˆ‘ä»¬çš„Y+, Z- (å) = æˆ‘ä»¬çš„Y-   
              
            const spriteY = createTextSprite(i.toString(), "#3366ff");  
            spriteY.position.set(0, 0.5, i); // æ”¾åœ¨Zè½´ä¸Š  
            scene.add(spriteY);  
        }  
  
        // æ·»åŠ  X å’Œ Y æ ‡ç­¾  
        const labelX = createTextSprite("X", "red");  
        labelX.position.set(5.5, 0.5, 0);  
        labelX.scale.set(1.5, 1.5, 1.5);  
        scene.add(labelX);  
  
        const labelY = createTextSprite("Y", "blue");  
        labelY.position.set(0, 0.5, 5.5);   
        labelY.scale.set(1.5, 1.5, 1.5);  
        scene.add(labelY);  
  
        // --- 5. è§’è‰² (å°æ–¹) ---  
        const playerGroup = new THREE.Group();  
        scene.add(playerGroup);  
  
        // èº«ä½“  
        const bodyGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);  
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0xFFD700 }); // é‡‘è‰²  
        const body = new THREE.Mesh(bodyGeo, bodyMat);  
        body.position.y = 0.4;  
        body.castShadow = true;  
        playerGroup.add(body);  
  
        // çœ¼ç›  
        const eyeGeo = new THREE.BoxGeometry(0.1, 0.1, 0.05);  
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });  
        const eyeLeft = new THREE.Mesh(eyeGeo, eyeMat);  
        eyeLeft.position.set(-0.2, 0.5, 0.4);  
        playerGroup.add(eyeLeft);  
        const eyeRight = eyeLeft.clone();  
        eyeRight.position.set(0.2, 0.5, 0.4);  
        playerGroup.add(eyeRight);  
  
        // --- 6. åŠ¨ç”»é€»è¾‘ ---  
          
        let targetPosition = new THREE.Vector3(0, 0, 0);  
        let isMoving = false;  
          
        // å±å¹•åæ ‡è½¬æ¢  
        const bubble = document.getElementById('bubble');  
  
        function updateBubble() {  
            const vector = playerGroup.position.clone();  
            vector.y += 1.2; // åœ¨å¤´é¡¶  
            vector.project(camera);  
  
            const x = (vector.x * .5 + .5) * window.innerWidth;  
            const y = (-(vector.y * .5) + .5) * window.innerHeight;  
  
            bubble.style.display = 'block';  
            bubble.style.left = `${x}px`;  
            bubble.style.top = `${y}px`;  
              
            // è¿™é‡Œè¦åè½¬ä¸€ä¸‹Zçš„æ˜¾ç¤ºï¼Œå› ä¸ºåœ¨3Dé‡Œæˆ‘ä»¬ç”¨Zä»£æ›¿Y  
            // ä¸ºäº†è®©æ•™å­¦æ›´ç›´è§‚ï¼Œæˆ‘ä»¬å‡è®¾ Zè½´æ­£æ–¹å‘ = Yè½´æ­£æ–¹å‘  
            bubble.innerHTML = `( $${Math.round(playerGroup.position.x)}, $${Math.round(playerGroup.position.z)} )`;  
        }  
  
        // æŒ‰é’®ç‚¹å‡»äº‹ä»¶  
        document.getElementById('goBtn').addEventListener('click', () => {  
            const xVal = parseInt(document.getElementById('inputX').value) || 0;  
            const yVal = parseInt(document.getElementById('inputY').value) || 0;  
              
            // é™åˆ¶èŒƒå›´  
            const safeX = Math.max(-5, Math.min(5, xVal));  
            const safeY = Math.max(-5, Math.min(5, yVal));  
  
            // æ›´æ–°ç›®æ ‡ (æ³¨æ„ï¼šè¾“å…¥çš„Yå¯¹åº”3Dé‡Œçš„Z)  
            targetPosition.set(safeX, 0, safeY);  
            isMoving = true;  
  
            // æ›´æ–°æ–‡å­—  
            document.getElementById('message').innerHTML =   
                `æ”¶åˆ°æŒ‡ä»¤ï¼<br>æ­£åœ¨å‰å¾€ <b>($${safeX}, $${safeY})</b>...<br>` +  
                `<small>Xèµ° $${safeX} æ ¼ï¼ŒYèµ° $${safeY} æ ¼</small>`;  
        });  
  
        // æ¸²æŸ“å¾ªç¯  
        function animate() {  
            requestAnimationFrame(animate);  
              
            controls.update();  
  
            if (isMoving) {  
                // å¹³æ»‘ç§»åŠ¨ (Lerp)  
                const step = 0.05; // é€Ÿåº¦  
                playerGroup.position.x += (targetPosition.x - playerGroup.position.x) * step;  
                playerGroup.position.z += (targetPosition.z - playerGroup.position.z) * step;  
                  
                // ç®€å•çš„è·³è·ƒåŠ¨ç”» (æ­£å¼¦æ³¢)  
                const dist = playerGroup.position.distanceTo(targetPosition);  
                if(dist > 0.05) {  
                    // ç§»åŠ¨æ—¶è·³è·ƒ  
                    playerGroup.position.y = Math.abs(Math.sin(Date.now() * 0.01)) * 0.5;  
                    // é¢å‘ç›®æ ‡  
                    playerGroup.lookAt(targetPosition.x, playerGroup.position.y, targetPosition.z);  
                } else {  
                    // åˆ°è¾¾ç›®æ ‡  
                    playerGroup.position.set(targetPosition.x, 0, targetPosition.z);  
                    playerGroup.rotation.set(0,0,0); // æ‘†æ­£  
                    isMoving = false;  
                    document.getElementById('message').innerHTML = `âœ… æˆ‘åˆ°äº†ï¼<br>å½“å‰ä½ç½®: <b>($${targetPosition.x}, $${targetPosition.z})</b>`;  
                }  
            }  
  
            updateBubble();  
            renderer.render(scene, camera);  
        }  
  
        // çª—å£å¤§å°è°ƒæ•´  
        window.addEventListener('resize', () => {  
            camera.aspect = window.innerWidth / window.innerHeight;  
            camera.updateProjectionMatrix();  
            renderer.setSize(window.innerWidth, window.innerHeight);  
        });  
  
        animate();  
    </script>  
</body>  
</html>  
